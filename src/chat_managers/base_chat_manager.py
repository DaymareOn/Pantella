import asyncio
from src.logging import logging
import wave

chat_manager_slug = "base_chat_manager"
valid_games = []

class BaseChatManager:
    def __init__(self, conversation_manager, valid_games=None, chat_manager_slug=None):
        self.conversation_manager = conversation_manager
        self.game_interface = self.conversation_manager.game_interface
        self.config = self.conversation_manager.config
        self.game = self.config.game_id
        if valid_games == None:
            logging.error(f"Valid games not implemented for chat manager {self.__class__.__name__}")
            raise NotImplementedError
        if chat_manager_slug == None:
            logging.error(f"Chat manager slug not implemented for chat manager {self.__class__.__name__}")
            raise NotImplementedError
        self.valid_games = valid_games
        self.chat_manager_slug = chat_manager_slug
        self.active_character = None

    async def get_audio_duration(self, audio_file):
        """Check if the external software has finished playing the audio file"""
        with wave.open(audio_file, 'r') as wf:
            frames = wf.getnframes()
            rate = wf.getframerate()
        # wait `buffer` seconds longer to let processes finish running correctly
        duration = frames / float(rate) + self.wait_time_buffer
        return duration

    async def send_audio_to_external_software(self, queue_output):
        """Send audio file to external software e.g. Skyrim, Fallout 4, etc."""
        logging.info(f"Dialogue to play: {queue_output[0]}")
        logging.error(f"send_audio_to_external_software not implemented for chat manager {self.__class__.__name__}")
        raise NotImplementedError

    async def send_response(self, sentence_queue, event):
        """Send response from sentence queue generated by `process_response()`"""
        while True: # keep getting audio files from the queue until the queue is empty
            queue_output = await sentence_queue.get() # get the next audio file from the queue
            if queue_output is None:
                logging.info('End of sentences')
                break # stop getting audio files from the queue if the queue is empty
            await self.send_audio_to_external_software(queue_output) # send the audio file to the external software and start playing it.
            # wait for the audio playback to complete before getting the next file
            audio_duration = await self.get_audio_duration(queue_output[0])
            # wait for the audio playback to complete before getting the next file
            logging.info(f"Waiting {int(round(audio_duration,4))} seconds for audio to finish playing...")
            await asyncio.sleep(audio_duration)
